{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the Karith documentation website.</p> <p>Karith is an arithmetic parser for Kotlin. It takes arithmetic expressions as a String and calculates them into a result. It can also handle expressions that contains variables.</p> <p>It is designed to be easy to use and highly configurable. It comes with builtin functions, operators and constants but can be extended with custom elements.</p> <p>This library is built on Kotlin Multiplatform. It does not require any external dependencies.</p>"},{"location":"#pages","title":"Pages","text":"<ul> <li>Quickstart</li> <li>Advanced usage</li> <li>Building</li> <li>Glossary</li> </ul>"},{"location":"#external-links","title":"External links","text":"<ul> <li>KDoc</li> <li>GitHub repository</li> <li>Maven Central</li> </ul>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#custom-elements","title":"Custom elements","text":"<p>Karith provides an easy way to extend the builtin sets of operators, functions, constants and modules to create your own.</p> <pre><code>val atOperator = createOperator(\"@\", 12) { a, b -&gt; (a + b) * (a - b) }\n// Uses the \"@\" key\n// Same precedence as multiplication and division\n// Left-associative\n// 2 @ 3 = (2 + 3) * (2 - 3)\n\nval dollarOperator = createOperator(\"$\", 15, false) { a, b -&gt; a.pow(b * E) }\n// Uses the \"$\" key\n// Same precedence as power\n// Right-associative (typical for exponentiation operators)\n// 2 $ 3 = 2 ^ (3 * e)\n\nval negFunction = createFunction(\"neg\") { a -&gt; -a }\n// Uses the \"neg\" key\n// neg(2) = -2\n\nval max3Function = createFunction(\"max3\") { a, b, c -&gt; max(max(a, b), c) }\n// Uses the \"max3\" key\n// max3(2, 3, 1) = 3\n\nval pConstant = createConstant(\"p\", 3.14)\n// Uses the \"p\" key\n// p * 2 = 6.28\n\nval customModule = createModule {\n    withOperator(atOperator, dollarOperator)\n    withFunction(negFunction, max3Function)\n    withConstant(pConstant)\n}\n// Regroup all of our custom elements in a module\n</code></pre>"},{"location":"advanced/#custom-context","title":"Custom context","text":"<p>These elements can then be added to your own custom context.</p> <pre><code>val customCtx = createDefaultContext {\n    // Includes the operations and functions from the default context\n    // Now we add our custom elements\n    withOperator(atOperator, dollarOperator)\n    withFunction(negFunction, max3Function)\n    withConstant(pConstant)\n}\n\n// Or we can simply include the module that already regroups all of our elements\nval customCtx = createDefaultContext {\n    include(customModule)\n}\n\n// If we want to create a context from scratch (no builtin operations/functions included)\nval customCtx = createContext {\n    include(customModule)\n}\n</code></pre> <p>If an element with the same key already exists in the context, it will be ignored.</p> <p>A context can also specify a certain \"combiner operator\" using the <code>withCombinerOperator</code> method. For example, in the default context, the combiner operator is <code>*</code> because when combining two elements that don't have an operator inbetween, a multiplication is implied: <code>3a = 3 * a</code>.</p>"},{"location":"building/","title":"Building","text":"<p>You can build Karith using these commands:</p> <pre><code>git clone https://github.com/skyecodes/Karith\ncd Karith\n./gradlew build\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":""},{"location":"glossary/#operator","title":"Operator","text":"<ul> <li>Element that represents an operation between the 2 elements next to it</li> <li>Represented by the interface <code>KthOperator</code></li> <li>Example: <code>+</code> (<code>a + b</code>), <code>/</code> (<code>a / b</code>)</li> <li>Can be created using the methods <code>createOperator</code> and <code>asOperator</code></li> <li>Can be included in a module or a context using <code>withOperation</code></li> </ul>"},{"location":"glossary/#function","title":"Function","text":"<ul> <li>Element that calculates a value based on a certain number of parameters</li> <li>Represented by the interface <code>KthFunction</code></li> <li>Example: <code>sin</code> (<code>sin(a)</code>), <code>max</code> (<code>max(a, b)</code>)</li> <li>Can be created using the methods <code>createFunction</code> and <code>asFunction</code></li> <li>Can be included in a module or a context using <code>withFunction</code></li> </ul>"},{"location":"glossary/#constant","title":"Constant","text":"<ul> <li>Element that represents a constant value</li> <li>Represented by the interface <code>KthConstant</code></li> <li>Example: <code>pi</code> (<code>2 pi r</code>), <code>e</code> (<code>e^x</code>)</li> <li>Can be created using the methods <code>createConstant</code> and <code>asConstant</code></li> <li>Can be included in a module or a context using <code>withConstant</code></li> </ul>"},{"location":"glossary/#module","title":"Module","text":"<ul> <li>Group of operators, functions and constants</li> <li>Represented by the interface <code>KthModule</code></li> <li>Can be created using the method <code>buildModule</code></li> <li>Can be included in a module or a context using <code>include</code></li> </ul>"},{"location":"glossary/#context","title":"Context","text":"<ul> <li>Object that defines all the operators, functions and constants that can be used</li> <li>Represented by the interface <code>KthContext</code></li> <li>Can be created using the methods <code>buildContext</code> and <code>buildDefaultContext</code></li> </ul>"},{"location":"glossary/#expression","title":"Expression","text":"<ul> <li>Arithmetic expression that has been parsed into a sorted list of tokens</li> <li>Can be used to calculate a result</li> <li>Represented by the interface <code>KthExpression</code></li> </ul>"},{"location":"kdoc-module/","title":"Module Karith","text":""},{"location":"kdoc-module/#welcome-to-the-karith-kdoc","title":"Welcome to the Karith KDoc.","text":"<p>Other links:</p> <ul> <li>Documentation (WIP)</li> <li>GitHub repository</li> <li>Maven Central</li> </ul>"},{"location":"kdoc-module/#package-comskyecodeskarith","title":"Package com.skyecodes.karith","text":"<p>Contains all the types, functions and properties that can be used in the Karith API.</p>"},{"location":"kdoc-module/#package-comskyecodeskarithbuiltin","title":"Package com.skyecodes.karith.builtin","text":"<p>Contains some builtin modules, operators, functions and constants. </p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>The library is available on Maven Central.</p> Gradle (Kotlin)Gradle (Groovy)Maven <pre><code>implementation(\"com.skyecodes.karith:karith:0.2.0\")\n</code></pre> <pre><code>implementation 'com.skyecodes.karith:karith:0.2.0'\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.skyecodes.karith&lt;/groupId&gt;\n    &lt;artifactId&gt;karith&lt;/artifactId&gt;\n    &lt;version&gt;0.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"quickstart/#simple-example","title":"Simple example","text":"<pre><code>println(calculateResult(\"1 + 2\").orThrow()) // 3.0\nprintln(calculateResultWith(\"3a + b\", \"a\" to 1, \"b\" to 2).orThrow()) // 5.0\nprintln(\"6 % 4\".calculateResult().orThrow()) // 2.0\nprintln(\"6 / min(x,y)\".calculateResultWith(\"x\" to 2, \"y\" to 3).orThrow()) // 3.0\n</code></pre>"},{"location":"quickstart/#contexts-and-modules","title":"Contexts and modules","text":"<p>A context is an object that contains all the operators, functions and constants that you can use in an expression. It is the entry point of the library as it is required in order to parse an expression. A context can include some modules, operators, functions and constants in it.</p> <p>You can easily create your own context using helper functions. Here is an example:</p> <pre><code>// creates a context with basic operators and functions:\n// contains the same elements as the default context\nval ctx = buildDefaultContext()\n\n// creates a context with + and - operators only\nval ctx = buildContext { withOperators(Operators.PLUS, Operators.MINUS) }\n</code></pre> <p>To see how to create your own operators, functions and constants, check the Advanced page.</p> <p>Default context</p> <p>In the Simple example, the methods <code>calculateResult</code>, <code>calculateResultWith</code>, <code>calculateResult</code> and <code>calculateResultWith</code> implicitly use a default context. This default context includes basic operators and math functions. It is appropriate to use it in most cases, unless you need to use your own custom operators or functions.</p>"},{"location":"quickstart/#parsing-an-expression","title":"Parsing an expression","text":"<p>You can parse an expression using the <code>parseExpression</code> or <code>parseExpressionWith</code> methods. You can either pass the expression string as a paremeter or use it as receiver.</p> <pre><code>// As parameter\nval expr = ctx.parseExpression(\"1 + 2\")\nval expr = ctx.parseExpressionWith(\"3a + b\", \"a\", \"b\")\n\n// As receiver\nwith(ctx) {\n    val expr = \"6 % 4\".parseExpression()\n    val expr = \"6 / min(x,y)\".parseExpressionWith(\"x\", \"y\")\n}\n</code></pre> <p>All of these methods return a <code>KthParsingResult</code>, which represents either a <code>KtxResult.Success</code> containing a <code>KtxExpression</code>, or a <code>KtxResult.Error</code> containing a <code>KthParsingException</code>.</p> <p>When using <code>parseExpressionWith</code>, you can pass the name of the variables as arguments. During parsing, if an unknown variable is found, a <code>KtxResult.Error</code> will be returned. Variables that are passed as parameter but not used in the expression are ignored.</p> <pre><code>val exprError = ctx.parseExpressionWith(\"3a + b\", \"a\")\n// KtxResult.Error(KthIllegalTokenException): \"b\" was not declared as a variable\n\nval exprIgnored = ctx.parseExpressionWith(\"3a + b\", \"a\", \"b\", \"c\")\n// KtxResult.Success(KthExpression): \"c\" is ignored\n</code></pre> <ul> <li>In the first example above, only <code>a</code> is declared as a variable, so an error is returned because <code>b</code> is not a number,   an operator or a constant.</li> <li>In the second example, the expression is parsed correctly. <code>c</code> is ignored because it is not present in the expression.</li> </ul> <p>If you don't want to declare the variables while parsing, but rather only provide variables during calculation, you can use the <code>parseExpression</code> and <code>parseExpression</code> methods.</p> <pre><code>val expr = ctx.parseExpression(\"3a + b\")\n// KtxResult.Success(KthExpression): the variables \"a\" and \"b\" have been automatically detected\n</code></pre>"},{"location":"quickstart/#calculating-a-result","title":"Calculating a result","text":"<p>You can calculate the result of an expression using the <code>calculateResult</code> or <code>calculateResultWith</code> method of an expression.</p> <pre><code>val expr1 = ctx.parseExpression(\"1 + 2\")\nval res1 = expr.calculateResult() // 3.0\n\nval expr2 = ctx.parseExpressionWith(\"3a + b\", \"a\", \"b\")\nval res2 = expr.calculateResultWith(\"a\" to 1, \"b\" to 2) // 5.0\n</code></pre> <p>Both of these methods return a <code>KthCalculationResult</code>, which represents either a <code>KtxResult.Success</code> containing the result as a <code>Double</code>, or a <code>KtxResult.Error</code> containing a <code>KthCalculationException</code>.</p> <p>All the variables detected in the expression must be provided.</p> <pre><code>val expr = ctx.parseExpression(\"3a + b\")\n// KtxResult.Success(KthExpression): the variables \"a\" and \"b\" have been automatically detected\n\nval res1 = expr.calculateResultWith(\"a\" to 1, \"b\" to 2)\n// KtxResult.Success(5.0): the variables \"a\" and \"b\" have been provided\nval res2 = expr.calculateResultWith(\"a\" to 1)\n// KtxResult.Error(KthUndefinedVariableException): undefined variable \"b\"\n</code></pre>"},{"location":"quickstart/#caching","title":"Caching","text":"<p>Caching is implemented at two levels: context and expression.</p> <ul> <li>At the context level, expressions can be cached: given the same input expression string, <code>parseExpression</code> and   <code>parseExpressionWith</code> will return the same instance of <code>KthExpression</code> without having to parse it again.</li> <li>At the expression level, results can be cached: given the same input variables, <code>calculateResult</code> and   <code>calculateResultWith</code> will return the same result without having to calculate it again.</li> </ul> <p>Caching is enabled by default. It can be disabled at the context level by using the <code>disableCache</code> method while building the context, and at the expression level by using the <code>disableCache</code> method on the expression. Disabling the cache at the context level also disables it at the expression level. It can be manually re-enabled at the expression level by using the <code>enableCache</code> on expressions.</p> <p>The cache can be cleared at either level by using the <code>clearCache</code> method on the context or the expression.</p>"},{"location":"quickstart/#parse-and-calculate","title":"Parse and calculate","text":"<p>In the case you need to calculate the same expression many times with different variables, it is recommended to parse the expression into a <code>KtxExpression</code> once using <code>parseExpression</code> or <code>parseExpressionWith</code>, then reuse the same expression instance to run the <code>calculateResult</code> or <code>calculateResultWith</code> method.</p> <p>If you only need to parse and calculate an expression once, you can use the shortcut methods <code>calculateResult</code>, <code>calculateResultWith</code>, <code>calculateResult</code> and <code>calculateResultWith</code> directly on the context, without having to create an expression first. Internally, this does the same thing as chaining <code>parseExpression</code> and <code>calculateResult</code> (or <code>parseExpressionWith</code> and <code>calculateResultWith</code>).</p> <pre><code>val res = ctx.calculateResultWith(\"3a + b\", \"a\" to 1, \"b\" to 2)\n// KtxResult.Success(5.0)\n</code></pre> <p>These \"shortcut\" methods return a <code>KthParsingAndCalculationResult</code>, which represents either a <code>KtxResult.Success</code> containing the result as a <code>Double</code>, or a <code>KtxResult.Error</code> containing a <code>KthException</code>.</p>"},{"location":"quickstart/#summary","title":"Summary","text":"<pre><code>graph TB\n    KthContext([KthContext]) ==&gt;|\" parseExpression(With) \"| KthParsingResult{KthParsingResult};\n    KthParsingResult ==&gt;|Success| KthExpression[KthExpression];\n    KthParsingResult --&gt;|Error| KthParsingException(KthParsingException);\n    KthParsingResult -.-&gt;|Cache| KthContext\n    KthExpression ==&gt;|\" calculateResult(With) \"| KthCalculationResult{KthCalculationResult};\n    KthCalculationResult ==&gt;|Success| Double([Double]);\n    KthCalculationResult --&gt;|Error| KthCalculationException(KthCalculationException);\n    KthCalculationResult -.-&gt;|Cache| KthExpression\n    KthContext ==&gt;|\" calculateResult(With) \"| KthParsingAndCalculationResult{KthParsingAndCalculationResult}\n    KthParsingAndCalculationResult ==&gt;|Success| Double;\n    KthParsingAndCalculationResult --&gt;|Error| KthException(KthException);\n    KthException -.-&gt; KthCalculationException;\n    KthException -.-&gt; KthParsingException;\n    linkStyle 0,1,4,5,8,9 stroke-width: 2px;</code></pre>"}]}